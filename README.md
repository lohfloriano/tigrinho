# Tigrinho ‚Äì Jogo de Aposta



## Introdu√ß√£o



O **Tigrinho** √© um projeto desenvolvido para demonstrar conceitos de programa√ß√£o, manipula√ß√£o de dados e l√≥gica de controle em jogos de aposta. Inspirado em cl√°ssicos jogos de azar, o sistema simula um jogo de sorte que utiliza matrizes com s√≠mbolos para determinar o resultado de cada rodada. O projeto tamb√©m ilustra como √© poss√≠vel manipular os dados de forma a permitir que apenas alguns jogadores obtenham ganhos significativos, garantindo que a empresa mantenha sua lucratividade.



## Descri√ß√£o do Projeto



No Tigrinho, os usu√°rios podem se cadastrar, fazer login, adicionar saldo e participar de rodadas de apostas. Cada rodada gera uma matriz 3x3 com s√≠mbolos aleat√≥rios (representados por "üí∏", "üêÖ" e "üêØ"). Em determinadas condi√ß√µes (quando o n√∫mero aleat√≥rio gerado ultrapassa um limiar), o jogo for√ßa uma combina√ß√£o vencedora em uma linha ou diagonal, resultando em um ganho para o jogador. Entretanto, o mecanismo de c√°lculo e atualiza√ß√£o de saldo √© cuidadosamente ajustado para que, a longo prazo, a empresa tenha lucro.



## Funcionalidades



- **Cadastro e Login:**  

  O sistema permite o registro de novos usu√°rios e o login de usu√°rios j√° cadastrados. S√£o utilizados m√©todos para validar CPF e garantir que n√£o haja duplicidade de cadastro.



- **Gest√£o de Saldo:**  

  Os usu√°rios iniciam com um saldo padr√£o e podem adicionar cr√©ditos em valores pr√©-definidos (R$5, R$10, R$20 e R$50). O saldo √© atualizado e persistido em um arquivo de texto (`usuarios.txt`).



- **Mec√¢nica do Jogo:**  

  Em cada rodada, √© gerada uma matriz com s√≠mbolos aleat√≥rios. Em algumas situa√ß√µes, o jogo for√ßa a ocorr√™ncia de combina√ß√µes vencedoras (diagonais ou linha central) para determinar o ganho, que √© calculado por meio de um multiplicador aleat√≥rio.



- **Controle de Apostas:**  

  O sistema verifica se o saldo do usu√°rio √© suficiente para a aposta e, ap√≥s cada rodada, atualiza o saldo conforme o resultado (ganho ou perda).



## Requisitos



- Python 3.7 ou superior.

- Ambiente de execu√ß√£o que permita entrada e sa√≠da via console.



## Estrutura do C√≥digo e Detalhamento das Fun√ß√µes



A seguir, uma explica√ß√£o detalhada das fun√ß√µes e trechos principais do c√≥digo:



### 1. Fun√ß√µes de Valida√ß√£o e Entrada



- **`verificar_resposta(valor)`**  

  *Prop√≥sito:*  

  Verifica se a resposta do usu√°rio corresponde a alguma varia√ß√£o de ‚Äúsim‚Äù.  

  *C√≥digo:*  

  ```python

  def verificar_resposta(valor):

      param = ["y", "s", "ye", "yes", "sim", "sin", "si"]

      resul = True if valor in param else False

      return resul

  ```

  

- **`entrada_valida(mensagem)`**  

  *Prop√≥sito:*  

  Garante que o usu√°rio n√£o deixe o campo vazio na entrada de dados.  

  *C√≥digo:*  

  ```python

  def entrada_valida(mensagem):

      while True:

          dado = input(mensagem).strip()

          if dado:

              return dado

          print("Preencha o campo vazio.")

  ```



- **`validar_cpf(cpf)`**  

  *Prop√≥sito:*  

  Realiza a valida√ß√£o b√°sica do CPF, garantindo que seja composto por 11 d√≠gitos num√©ricos.  

  *C√≥digo:*  

  ```python

  def validar_cpf(cpf):

      return len(cpf) == 11 and cpf.isdigit()

  ```



- **`verificar_existencia(usuario, cpf)`**  

  *Prop√≥sito:*  

  Verifica se o nome de usu√°rio ou CPF j√° est√£o cadastrados no arquivo `usuarios.txt`, evitando duplicidade.  

  *C√≥digo:*  

  ```python

  def verificar_existencia(usuario, cpf):

      try:

          with open("usuarios.txt", "r") as arquivo:

              for linha in arquivo:

                  dados = linha.strip().split(",")

                  if len(dados) == 4:

                      nome_salvo, cpf_salvo, _, _ = dados

                      if usuario == nome_salvo:

                          print("\n‚ö†Ô∏è Nome de usu√°rio j√° existe. Escolha outro.")

                          return True

                      if cpf == cpf_salvo:

                          print("\n‚ö†Ô∏è CPF j√° cadastrado.")

                          return True

      except FileNotFoundError:

          pass

      return False

  ```



### 2. Cadastro, Login e Gest√£o de Saldo



- **`registrar()`**  

  *Prop√≥sito:*  

  Realiza o cadastro do usu√°rio, coletando nome, CPF e senha, e registra um saldo inicial (R$10).  

  *C√≥digo:*  

  ```python

  def registrar():

      usuario = entrada_valida("Digite seu nome de usu√°rio:")

      while True:

          cpf = input("Informe seu CPF:")

          if validar_cpf(cpf):

              break

          else:

              print("CPF inv√°lido. Informe apenas n√∫meros com 11 d√≠gitos.")

      senha = entrada_valida("Digite sua senha:")

      if verificar_existencia(usuario, cpf):

          print("\n‚ö†Ô∏è Cadastro n√£o permitido. Tente novamente.\n")

          return None, None, None

      saldo_inicial = 10

      with open("usuarios.txt", "a") as arquivo:

          arquivo.write(f"{usuario},{cpf},{senha},{saldo_inicial}\n")

      print("\n‚úÖ Cadastro realizado com sucesso!")

      return usuario, senha, saldo_inicial

  ```



- **`login()`**  

  *Prop√≥sito:*  

  Permite o login do usu√°rio, verificando as credenciais e recuperando o saldo atual.  

  *C√≥digo:*  

  ```python

  def login():

      while True:

          login_usuario = entrada_valida("Digite seu nome de usu√°rio: ")

          login_senha = entrada_valida("Digite sua senha: ")

          with open("usuarios.txt", "r") as arquivo:

              usuarios_cadastrados = arquivo.readlines()

          for linha in usuarios_cadastrados:

              dados = linha.strip().split(",")

              if len(dados) == 4:

                  nome_salvo, _, senha_salva, saldo = dados

                  if login_usuario == nome_salvo and login_senha == senha_salva:

                      print("\n‚úÖ Login realizado com sucesso! Bem-vindo de volta!")

                      return login_usuario, float(saldo)

          print("‚ö†Ô∏è Usu√°rio ou senha incorretos. Tente novamente.")

  ```



- **`atualizar_saldo(usuario, novo_saldo)`**  

  *Prop√≥sito:*  

  Atualiza o saldo do usu√°rio no arquivo `usuarios.txt`, garantindo a persist√™ncia dos dados ap√≥s cada jogada.  

  *C√≥digo:*  

  ```python

  def atualizar_saldo(usuario, novo_saldo):

      linhas = []

      with open("usuarios.txt", "r") as arquivo:

          for linha in arquivo:

              dados = linha.strip().split(",")

              if len(dados) == 4 and dados[0] == usuario:

                  dados[3] = str(novo_saldo)

              linhas.append(",".join(dados))

      with open("usuarios.txt", "w") as arquivo:

          arquivo.write("\n".join(linhas) + "\n")

  ```



- **`adicionar_saldo(saldo)`**  

  *Prop√≥sito:*  

  Permite ao usu√°rio adicionar cr√©ditos ao seu saldo, escolhendo entre valores pr√©-definidos.  

  *C√≥digo:*  

  ```python

  def adicionar_saldo(saldo):

      print("\nüí∞ Op√ß√µes para adicionar saldo: 5, 10, 20, 50 reais")

      while True:

          try:

              valor = int(input("Quanto deseja adicionar? "))

              if valor in [5, 10, 20, 50]:

                  return saldo + valor

              else:

                  print("Op√ß√£o inv√°lida. Escolha entre 5, 10, 20 ou 50 reais.")

          except ValueError:

              print("Digite um n√∫mero v√°lido.")

  ```



### 3. L√≥gica do Jogo ‚Äì O Tigrinho



- **`gerar_matriz()`**  

  *Prop√≥sito:*  

  Gera uma matriz 3x3 com s√≠mbolos aleat√≥rios, representando o ‚Äútabuleiro‚Äù do jogo. Em determinadas condi√ß√µes, for√ßa a cria√ß√£o de combina√ß√µes vencedoras (como linhas ou diagonais iguais), manipulando os resultados para que somente alguns jogadores ganhem, mantendo a lucratividade da empresa.  

  *C√≥digo:*  

  ```python

  def gerar_matriz():

      simbolos = ["üí∏", "üêÖ", "üêØ"]

      matriz = [[random.choice(simbolos) for _ in range(3)] for _ in range(3)]

      sorte = random.randint(1, 10)

      if sorte > 8:

          modo_ganho = random.choice(["diagonal1", "diagonal2", "meio"])

          item = random.choice(["üí∏", "üêÖ", "üêØ"])

          if modo_ganho == "meio":

              matriz[1][0], matriz[1][1], matriz[1][2] = item, item, item

          elif modo_ganho == "diagonal1":

              matriz[0][0], matriz[1][1], matriz[2][2] = item, item, item

          else:

              matriz[2][0], matriz[1][1], matriz[0][2] = item, item, item

  

      print("-" * 20)

      for i, linha in enumerate(matriz):

          format = "  " if i != 1 else "->"

          print(format, " | ".join(linha).strip())

      print("-" * 20)

  

      return matriz

  ```



- **`verificar_vitoria_spin(matriz)`**  

  *Prop√≥sito:*  

  Verifica se a matriz gerada cont√©m uma combina√ß√£o vencedora nas diagonais ou na linha do meio. Retorna um valor booleano indicando vit√≥ria e a quantidade de formas vencedoras encontradas.  

  *C√≥digo:*  

  ```python

  def verificar_vitoria_spin(matriz):

      resul, quant = None, 0

      diagonal = matriz[0][0] == matriz[1][1] == matriz[2][2]

      diagonal2 = matriz[2][0] == matriz[1][1] == matriz[0][2]

      meio = matriz[1][0] == matriz[1][1] == matriz[1][2]

  

      vetor = [diagonal, diagonal2, meio]

      for valor in vetor:

          if valor == True:

              resul = True

              quant += 1

      return (resul, quant)

  ```



- **Fun√ß√£o `calc_valor()` interna em `jogar()`**  

  *Prop√≥sito:*  

  Calcula um multiplicador para o valor apostado com base em uma combina√ß√£o de n√∫meros inteiros e fra√ß√µes, ponderados para favorecer a lucratividade da empresa.  

  *C√≥digo (resumido dentro de `jogar()`):*  

  ```python

  def calc_valor():

      numeros = [10, 20, 30, 50, 100]

      quebrados = random.randint(1, 101)

      pesos = [20, 8, 3, 2, 1]

      pesos_normalizados = [p / sum(pesos) for p in pesos]

  

      numero_aleatorio = random.choices(numeros, weights=pesos_normalizados, k=1)[0]

      numero = 1 + (numero_aleatorio + quebrados) / 100

      return float(f\"{numero:.2f}\")

  ```



- **`jogar(nome, saldo, param = \"-s\")`**  

  *Prop√≥sito:*  

  Gerencia o fluxo principal do jogo, controlando cada rodada (ou ‚Äúgiro‚Äù), atualizando o saldo do jogador conforme o resultado de cada aposta. Se o jogador vence (conforme a fun√ß√£o de verifica√ß√£o de vit√≥ria), o saldo √© aumentado multiplicando o valor apostado; caso contr√°rio, o valor apostado √© deduzido.  

  *Destaques do fluxo:*  

  - Exibi√ß√£o do saldo atual e op√ß√µes de adicionar saldo.  

  - Solicita√ß√£o do valor a ser apostado, com verifica√ß√£o de saldo dispon√≠vel.  

  - Loop de rodadas onde:  

    - A matriz √© gerada.  

    - O resultado √© avaliado (fun√ß√£o `verificar_vitoria_spin()`).  

    - Em caso de vit√≥ria, o multiplicador √© calculado e o ganho √© computado.  

    - Em caso de derrota, o valor apostado √© subtra√≠do do saldo.  

    - Pergunta ao usu√°rio se deseja continuar jogando.  

  *C√≥digo (trecho principal):*  

  ```python

  def jogar(nome, saldo, param = "-s"):

      # [C√≥digo para adicionar saldo, se necess√°rio]

      print("\nVamos comecar a jogar!\n")

  

      rodada, win_count = 0, 0

      saldo_aposta = float(input("Digite quanto vai querer apostar: "))

      while saldo_aposta > saldo:

          saldo_aposta = float(input("Saldo insuficiente. Por favor, insira um valor coerente: "))

      while True:

          rodada += 1

          print(f"\n=== Giro {rodada} ===")

  

          matriz = gerar_matriz()

          resultado, peso = verificar_vitoria_spin(matriz)

  

          if resultado:

              valor_sorteado = calc_valor()

              print(" WIIN!!")

              if peso > 1:

                  print(f\"Parab√©ns!!! Voc√™ ganhou de {peso} formas diferentes. Bonifica√ß√£o aplicada!\")

              valor_peso = valor_sorteado

              valor_ganho = saldo_aposta * valor_peso

              print(f"Valor Ganho {valor_ganho:.2f}")

              saldo += valor_ganho - saldo_aposta

              saldo_aposta = valor_ganho

              win_count += 1

          else:

              saldo -= saldo_aposta

              print(f"Voc√™ perdeu. Saldo restante: {saldo}")

              print("N√£o foi dessa vez. Tente mais uma!")

  

          resposta = input("\nDeseja continuar? ").lower()

          if not verificar_resposta(resposta):

              break

          # Verifica saldo para nova aposta

          elif resposta and saldo < saldo_aposta:

              print("Saldo insuficiente. Regarregue para continuar!")

              resp = input(f"Deseja apostar os seus {saldo} reais? ")

              if verificar_resposta(resp):

                  saldo_aposta = saldo

              else:

                  break

          elif saldo == 0:

              print("Sem saldo! Recarrege para continuar.")

              break

  

      atualizar_saldo(nome, saldo)

      print("\n=== Fim dos Giros ===")

      print(f"Voc√™ obteve {win_count} giro(s) vencedor(es).")

      print(f"Seu saldo atual √© R${saldo}.")

  

      continuar = input("Deseja continuar jogando? (s/n): ").strip().lower()

      if continuar == "s":

          jogar(nome, saldo, param = "-n")

      else:

          print("Obrigado por jogar! At√© a pr√≥xima! üêØ")

  ```



- **`main()`**  

  *Prop√≥sito:*  

  Ponto de entrada do programa. Gerencia o fluxo de cadastro/login e inicia o jogo.  

  *C√≥digo:*  

  ```python

  def main():

      print(" Bem-vindo ao Tigrinho üêØ ")

      while True:

          escolha = input("Voc√™ j√° possui cadastro? (s/n): ").strip().lower()

          if escolha == "s":

              nome, saldo = login()

              if nome:

                  break

          elif escolha == "n":

              nome, _, saldo = registrar()

              if nome:

                  nome, saldo = login()

                  if nome:

                      break

          else:

              print("Por favor, responda com 's' para sim ou 'n' para n√£o.")

      jogar(nome, saldo)

  

  if __name__ == "__main__":

      main()

  ```



## Considera√ß√µes sobre a Manipula√ß√£o dos Dados



O jogo √© projetado para favorecer a empresa de apostas. A manipula√ß√£o ocorre em dois pontos cr√≠ticos:

- **Gera√ß√£o da Matriz:**  

  Ao gerar a matriz de s√≠mbolos, h√° uma chance (quando o n√∫mero aleat√≥rio `sorte` √© maior que 8) de for√ßar uma combina√ß√£o vencedora. Essa ‚Äúajuste‚Äù na gera√ß√£o das combina√ß√µes garante que somente em situa√ß√µes controladas ocorra o pagamento, balanceando os ganhos e perdas.

- **C√°lculo do Multiplicador:**  

  O multiplicador aplicado ao valor apostado √© calculado de forma a oferecer ganhos atrativos apenas em casos de m√∫ltiplas vit√≥rias, mantendo uma probabilidade menor de ocorr√™ncia e, assim, assegurando a margem de lucro para a empresa.



## Conclus√£o



O projeto **Tigrinho** serve como uma aplica√ß√£o pr√°tica dos conceitos de manipula√ß√£o de dados, controle de fluxo e l√≥gica de programa√ß√£o. Al√©m de demonstrar a implementa√ß√£o de um sistema de apostas, o projeto destaca a import√¢ncia do controle das condi√ß√µes de vit√≥ria para garantir a sustentabilidade financeira da opera√ß√£o.



---



Este README destina-se a ser uma documenta√ß√£o completa para a apresenta√ß√£o do projeto na disciplina de Fundamentos da Computa√ß√£o, evidenciando o detalhamento de cada fun√ß√£o e a l√≥gica de neg√≥cio aplicada. Se houver necessidade de maiores ajustes ou acr√©scimos, sinta-se √† vontade para propor melhorias.



